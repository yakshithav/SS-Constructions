"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVariant = getVariant;
exports.updateVariant = updateVariant;
exports.flpConfigurationExists = flpConfigurationExists;
exports.isTypescriptSupported = isTypescriptSupported;
exports.readUi5Config = readUi5Config;
exports.extractAdpConfig = extractAdpConfig;
exports.getAdpConfig = getAdpConfig;
exports.getWebappFiles = getWebappFiles;
exports.filterAndMapInboundsToManifest = filterAndMapInboundsToManifest;
const fs_1 = require("fs");
const path_1 = require("path");
const project_access_1 = require("@sap-ux/project-access");
/**
 * Get the app descriptor variant.
 *
 * @param {string} basePath - The path to the adaptation project.
 * @param {Editor} fs - The mem-fs editor instance.
 * @returns {Promise<DescriptorVariant>} The app descriptor variant.
 */
async function getVariant(basePath, fs) {
    const webappPath = await (0, project_access_1.getWebappPath)(basePath);
    if (fs) {
        return fs.readJSON((0, path_1.join)(webappPath, project_access_1.FileName.ManifestAppDescrVar));
    }
    return JSON.parse((0, fs_1.readFileSync)((0, path_1.join)(webappPath, project_access_1.FileName.ManifestAppDescrVar), 'utf-8'));
}
/**
 * Writes the updated variant content to the manifest.appdescr_variant file.
 *
 * @param {string} basePath - The base path of the project.
 * @param {DescriptorVariant} variant - The descriptor variant object.
 * @param {Editor} fs - The mem-fs editor instance.
 */
async function updateVariant(basePath, variant, fs) {
    fs.writeJSON((0, path_1.join)(await (0, project_access_1.getWebappPath)(basePath), project_access_1.FileName.ManifestAppDescrVar), variant);
}
/**
 * Checks if FLP configuration changes exist in the manifest.appdescr_variant.
 *
 * This function determines whether there are changes of type `appdescr_app_changeInbound`
 * or `appdescr_app_addNewInbound` present in the content of the descriptor variant.
 *
 * @param {DescriptorVariant} variant - The descriptor variant object to check for FLP configuration changes.
 * @returns {Promise<boolean>} Returns `true` if FLP configuration changes exist, otherwise `false`.
 */
function flpConfigurationExists(variant) {
    return variant.content?.some(({ changeType }) => changeType === 'appdescr_app_changeInbound' || changeType === 'appdescr_app_addNewInbound');
}
/**
 * Checks whether TypeScript is supported in the project by verifying the existence of `tsconfig.json`.
 *
 * @param basePath - The base path of the project.
 * @param fs - An optional `mem-fs-editor` instance to check for the file's existence.
 * @returns `true` if `tsconfig.json` exists, otherwise `false`.
 */
function isTypescriptSupported(basePath, fs) {
    const path = (0, path_1.join)(basePath, 'tsconfig.json');
    return fs ? fs.exists(path) : (0, fs_1.existsSync)(path);
}
/**
 * Reads the UI5 YAML configuration and returns the parsed `UI5Config` instance.
 *
 * @param {string} basePath - Adaptation project root
 * @param {string} yamlPath - Relative or absolute path to the ui5.yaml file
 * @returns {Promise<UI5Config>} The `UI5Config` object.
 */
async function readUi5Config(basePath, yamlPath) {
    const ui5ConfigPath = (0, path_1.isAbsolute)(yamlPath) ? yamlPath : (0, path_1.join)(basePath, yamlPath);
    return (0, project_access_1.readUi5Yaml)((0, path_1.dirname)(ui5ConfigPath), (0, path_1.basename)(ui5ConfigPath));
}
/**
 * Extracts the `adp` preview configuration from a UI5 YAML config (if present).
 *
 * @param {UI5Config} ui5Conf Parsed UI5 configuration
 * @returns The `AdpPreviewConfig` object if found, otherwise `undefined`.
 */
function extractAdpConfig(ui5Conf) {
    const customMiddleware = ui5Conf.findCustomMiddleware('fiori-tools-preview') ??
        ui5Conf.findCustomMiddleware('preview-middleware');
    return customMiddleware?.configuration?.adp;
}
/**
 * Convenience wrapper that reads the ui5.yaml and directly returns the ADP preview configuration.
 * Throws if the configuration cannot be found.
 *
 * @param basePath  Adaptation project root
 * @param yamlPath  Relative or absolute path to the ui5.yaml file
 * @returns The `AdpPreviewConfig` object if found, otherwise throws an error.
 */
async function getAdpConfig(basePath, yamlPath) {
    try {
        const ui5Conf = await readUi5Config(basePath, yamlPath);
        const adp = extractAdpConfig(ui5Conf);
        if (!adp) {
            throw new Error('Could not extract ADP configuration from ui5.yaml');
        }
        return adp;
    }
    catch (error) {
        const ui5ConfigPath = (0, path_1.isAbsolute)(yamlPath) ? yamlPath : (0, path_1.join)(basePath, yamlPath);
        throw new Error(`No system configuration found in ${(0, path_1.basename)(ui5ConfigPath)}`);
    }
}
/**
 * Get all files in the webapp folder.
 *
 * @param {string} basePath - The path to the adaptation project.
 * @returns {Promise<{ relativePath: string; content: string }[]>} The files in the webapp folder.
 */
async function getWebappFiles(basePath) {
    const dir = await (0, project_access_1.getWebappPath)(basePath);
    const files = [];
    const getFilesRecursivelySync = (directory) => {
        const dirents = (0, fs_1.readdirSync)(directory, { withFileTypes: true });
        for (const dirent of dirents) {
            const fullPath = (0, path_1.join)(directory, dirent.name);
            if (dirent.isFile()) {
                const content = (0, fs_1.readFileSync)(fullPath, 'utf-8');
                const relativePath = (0, path_1.relative)(dir, fullPath);
                files.push({ relativePath, content });
            }
            else if (dirent.isDirectory()) {
                getFilesRecursivelySync(fullPath);
            }
        }
    };
    getFilesRecursivelySync(dir);
    return files;
}
/**
 * Transforms an array of inbound objects from the SystemInfo API format into a ManifestNamespace.Inbound object.
 *
 * @param {Inbound[]} inbounds - The array of inbound objects to transform.
 * @returns {ManifestNamespace.Inbound | undefined} The transformed inbounds or undefined if input is empty.
 */
function filterAndMapInboundsToManifest(inbounds) {
    if (!inbounds || inbounds.length === 0) {
        return undefined;
    }
    const filteredInbounds = inbounds.reduce((acc, inbound) => {
        // Skip if hideLauncher is true
        if (!inbound?.content || inbound.content.hideLauncher === true) {
            return acc;
        }
        const { semanticObject, action } = inbound.content;
        if (semanticObject && action) {
            const key = `${semanticObject}-${action}`;
            acc[key] = inbound.content;
        }
        return acc;
    }, {});
    return Object.keys(filteredInbounds).length === 0 ? undefined : filteredInbounds;
}
//# sourceMappingURL=helper.js.map