"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extendAdditionalMessages = extendAdditionalMessages;
exports.extendValidate = extendValidate;
exports.applyExtensionFunction = applyExtensionFunction;
exports.withCondition = withCondition;
exports.extendWithOptions = extendWithOptions;
exports.hasAggregateTransformationsForEntity = hasAggregateTransformationsForEntity;
exports.filterAggregateTransformations = filterAggregateTransformations;
exports.convertEdmxToConvertedMetadata = convertEdmxToConvertedMetadata;
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const annotation_converter_1 = require("@sap-ux/annotation-converter");
const edmx_parser_1 = require("@sap-ux/edmx-parser");
const i18n_1 = require("../i18n");
/**
 * Extends an additionalMessages function.
 *
 * @param question - the question to which the validate function will be applied
 * @param addMsgFunc - the additional messages function which will be applied to the question
 * @param promptState - the runtime state of the prompts, this can be used to provide additional answers not defined by the prompt answers object
 * @returns the extended additional messages function
 */
function extendAdditionalMessages(question, addMsgFunc, promptState) {
    const addMsgs = question.additionalMessages;
    return (value, previousAnswers) => {
        // Allow non-prompt answer (derived answers) values to be passed to the additional messages function
        // We clone as answers should never be mutatable in prompt functions
        const combinedAnswers = { ...(0, cloneDeep_1.default)(previousAnswers), ...(0, cloneDeep_1.default)(promptState) };
        const extMsg = addMsgFunc(value, combinedAnswers);
        if (extMsg) {
            return extMsg; // Extended prompt message is returned first
        }
        // Defer to the original function if a valid message was not returned from the extended version
        return typeof addMsgs === 'function' ? addMsgs(value, previousAnswers) : undefined;
    };
}
/**
 * Extends a validate function. The extended function will be called first.
 *
 * @param question - the question to which the validate function will be applied
 * @param validateFunc - the validate function which will be applied to the question
 * @param promptState - the runtime state of the prompts, this can be used to provide additional answers not defined by the prompt answers object
 * @returns the extended validate function
 */
function extendValidate(question, validateFunc, promptState) {
    const validate = question.validate;
    return (value, previousAnswers) => {
        // Allow non-prompt answer (derived answers) values to be passed to the validate function
        const combinedAnswers = { ...(0, cloneDeep_1.default)(previousAnswers), ...(0, cloneDeep_1.default)(promptState) };
        const extVal = validateFunc?.(value, combinedAnswers);
        if (extVal !== true) {
            return extVal;
        }
        return typeof validate === 'function' ? validate(value, previousAnswers) : true;
    };
}
/**
 * Extend the existing prompt property function with the one specified in prompt options or add as new.
 *
 * @param question - the question to which the extending function will be applied
 * @param promptOption - prompt options, containing extending functions
 * @param funcName - the question property (function) name to extend
 * @param promptState - the runtime state of the prompts, this can be used to provide additional answers not defined by the prompt answers object
 * @returns the extended question
 */
function applyExtensionFunction(question, promptOption, funcName, promptState) {
    let extendedFunc;
    if (funcName === 'validate' && promptOption.validate) {
        extendedFunc = extendValidate(question, promptOption.validate, promptState);
    }
    if (funcName === 'additionalMessages' && promptOption.additionalMessages) {
        extendedFunc = extendAdditionalMessages(question, promptOption.additionalMessages, promptState);
    }
    question = Object.assign(question, { [funcName]: extendedFunc });
    return question;
}
/**
 * Adds additional conditions to the provided questions.
 *
 * @param questions the questions to which the condition will be added
 * @param condition function which returns true or false
 * @returns the passed questions reference
 */
function withCondition(questions, condition) {
    questions.forEach((question) => {
        if (question.when !== undefined) {
            if (typeof question.when === 'function') {
                const when = question.when;
                question.when = (answers) => {
                    if (condition(answers)) {
                        return when(answers);
                    }
                    else {
                        return false;
                    }
                };
            }
            else {
                const whenValue = question.when;
                question.when = (answers) => {
                    return condition(answers) && whenValue;
                };
            }
        }
        else {
            question.when = condition;
        }
    });
    return questions;
}
/**
 * Updates questions with extensions for specific properties. Only `validate`, `default` and `additionalMessages` are currently supported.
 *
 * @param questions - array of prompts to be extended
 * @param promptOptions - the prompt options possibly containing function extensions
 * @param promptState - the runtime state of the prompts, this can be used to provide additional answers not defined by the prompt answers object
 * @returns - the extended questions
 */
function extendWithOptions(questions, promptOptions, promptState) {
    questions.forEach((question) => {
        const promptOptKey = question.name;
        const promptOpt = promptOptions[question.name];
        if (promptOpt) {
            const propsToExtend = Object.keys(promptOpt);
            for (const extProp of propsToExtend) {
                if (extProp === 'validate' || extProp === 'additionalMessages') {
                    question = applyExtensionFunction(question, promptOpt, extProp, promptState);
                }
                // Provided defaults will override built in defaults
                const defaultOverride = promptOptions[promptOptKey].default;
                if (defaultOverride) {
                    question.default = defaultOverride;
                }
            }
        }
    });
    return questions;
}
/**
 * Checks if the given entity set name has aggregate transformations in the metadata.
 *
 * @param metadata The metadata (edmx) of the service.
 * @param entitySetName The entity set name to check for aggregate transformations.
 * @returns true if the entity set has aggregate transformations, false otherwise.
 */
function hasAggregateTransformationsForEntity(metadata, entitySetName) {
    if (!entitySetName) {
        return false;
    }
    return filterAggregateTransformations(metadata.entitySets).some((entitySet) => entitySet.name === entitySetName);
}
/**
 * Returns only entity sets that have the `Aggregation.ApplySupported` annotation term with the `Transformations` property.
 * This can be found within the entity set annotations or the entity type annotations.
 *
 * @param entitySets the entity sets to filter
 * @returns the filtered entity sets
 */
function filterAggregateTransformations(entitySets) {
    return entitySets.filter((entitySet) => {
        return (!!entitySet.annotations?.Aggregation?.ApplySupported?.Transformations ||
            !!entitySet.entityType?.annotations?.Aggregation?.ApplySupported?.Transformations);
    });
}
/**
 * Converts an EDMX string to a ConvertedMetadata object.
 *
 * @param edmx - The EDMX string to convert.
 * @returns The converted metadata object.
 * @throws If the EDMX cannot be parsed or the OData version is unparseable.
 */
function convertEdmxToConvertedMetadata(edmx) {
    try {
        const convertedMetadata = (0, annotation_converter_1.convert)((0, edmx_parser_1.parse)(edmx));
        const parsedOdataVersion = parseInt(convertedMetadata?.version, 10);
        if (Number.isNaN(parsedOdataVersion)) {
            throw new Error((0, i18n_1.t)('errors.unparseableOdataVersion'));
        }
        return convertedMetadata;
    }
    catch (error) {
        throw new Error((0, i18n_1.t)('errors.unparseableMetadata', { error: error.message }));
    }
}
//# sourceMappingURL=helpers.js.map