"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergedRawMetadata = exports.RawMetadataInstance = exports.ensureArray = void 0;
/**
 * Either returns the sourceObject or the sourceObject wrapped in an array.
 *
 * @param sourceObject the object you want to check
 * @returns the source object wrapped in an array.
 */
function ensureArray(sourceObject) {
    if (sourceObject === undefined || sourceObject === null) {
        return [];
    }
    if (Array.isArray(sourceObject)) {
        return sourceObject;
    }
    else {
        return [sourceObject];
    }
}
exports.ensureArray = ensureArray;
/**
 *
 */
class RawMetadataInstance {
    /**
     * @param fileIdentification the name of the file you are parsing, mostly for reference
     * @param version the version of the metadata currently evaluated
     * @param schema the parsed schema
     * @param references a list of all the references currently used in your file
     */
    constructor(fileIdentification, version, schema, references) {
        this.identification = fileIdentification;
        this.references = references;
        this.version = version;
        this.schema = schema;
    }
}
exports.RawMetadataInstance = RawMetadataInstance;
/**
 *
 */
class MergedRawMetadata {
    get references() {
        return this._references;
    }
    get schema() {
        return {
            associations: this._associations,
            associationSets: this._associationSets,
            annotations: this._annotations,
            entityContainer: this._entityContainer,
            namespace: this._namespace,
            entitySets: this._entitySets,
            singletons: this._singletons,
            complexTypes: this._complexTypes,
            typeDefinitions: this._typeDefinitions,
            actions: this._actions,
            actionImports: this._actionImports,
            entityTypes: this._entityTypes
        };
    }
    /**
     * @param initialParserOutput
     */
    constructor(initialParserOutput) {
        this._references = [];
        this._parserOutput = [];
        this._annotations = {};
        this._associations = [];
        this._associationSets = [];
        this._entitySets = [];
        this._singletons = [];
        this._actions = [];
        this._actionImports = [];
        this._entityContainer = {
            _type: 'EntityContainer',
            fullyQualifiedName: ''
        };
        this._entityTypes = [];
        this._complexTypes = [];
        this._typeDefinitions = [];
        this.identification = 'mergedParserInstance';
        this.version = initialParserOutput.version;
        this._namespace = initialParserOutput.schema.namespace;
    }
    /**
     * @param parserOutput
     */
    addParserOutput(parserOutput) {
        this._parserOutput.push(parserOutput);
        this._references = this._references.concat(parserOutput.references);
        this._associations = this._associations.concat(parserOutput.schema.associations);
        this._associationSets = this._associationSets.concat(parserOutput.schema.associationSets);
        this._annotations = Object.assign(this._annotations, parserOutput.schema.annotations);
        this._entitySets = this._entitySets.concat(parserOutput.schema.entitySets);
        this._singletons = this._singletons.concat(parserOutput.schema.singletons);
        this._actions = this._actions.concat(parserOutput.schema.actions);
        this._actionImports = this._actionImports.concat(parserOutput.schema.actionImports);
        this._entityTypes = this._entityTypes.concat(parserOutput.schema.entityTypes);
        this._complexTypes = this._complexTypes.concat(parserOutput.schema.complexTypes);
        this._typeDefinitions = this._typeDefinitions.concat(parserOutput.schema.typeDefinitions);
        if (parserOutput.schema.entityContainer.fullyQualifiedName.length > 0) {
            this._entityContainer = Object.assign(this._entityContainer, parserOutput.schema.entityContainer);
        }
    }
}
exports.MergedRawMetadata = MergedRawMetadata;
//# sourceMappingURL=utils.js.map