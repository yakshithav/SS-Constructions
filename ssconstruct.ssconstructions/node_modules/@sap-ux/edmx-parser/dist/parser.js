"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const xml_js_1 = require("xml-js");
const utils_1 = require("./utils");
const v2annotationsSupport_1 = require("./v2annotationsSupport");
const collectionRegexp = /^Collection\((.+)\)$/;
// Type guards
/**
 * Check whether the navigation property is a v4 navigation property.
 *
 * @param navPropertyAttributes
 * @returns true if the navigationProperty is a v4 one
 */
function isV4NavProperty(navPropertyAttributes) {
    return (navPropertyAttributes.Type !== null &&
        navPropertyAttributes.Type !== undefined);
}
// Parser Methods
/**
 * Retrieves the name of the keys for that entity type.
 *
 * @param propertyRefs {EDMX.PropertyRef} property reference
 * @returns the entityType keys name
 */
function getEntityTypeKeys(propertyRefs) {
    return propertyRefs.map((propertyRef) => propertyRef._attributes.Name);
}
/**
 * Parse the EDMX.Property to retrieve the property.
 *
 * @param entityProperties
 * @param entityKeys
 * @param entityTypeFQN
 * @param annotationLists
 * @returns the properties
 */
function parseProperties(entityProperties, entityKeys, entityTypeFQN, annotationLists) {
    return entityProperties.reduce((outObject, entityProperty) => {
        const edmProperty = {
            _type: 'Property',
            name: entityProperty._attributes.Name,
            fullyQualifiedName: `${entityTypeFQN}/${entityProperty._attributes.Name}`,
            type: unaliasType(entityProperty._attributes.Type).type
        };
        if (entityProperty._attributes.MaxLength) {
            edmProperty.maxLength = parseInt(entityProperty._attributes.MaxLength, 10);
        }
        if (entityProperty._attributes.Precision) {
            edmProperty.precision = parseInt(entityProperty._attributes.Precision, 10);
        }
        if (entityProperty._attributes.Scale) {
            edmProperty.scale = parseInt(entityProperty._attributes.Scale, 10);
        }
        edmProperty.nullable = entityProperty._attributes.Nullable !== 'false';
        if (entityProperty._attributes.DefaultValue) {
            switch (edmProperty.type) {
                case 'Edm.Int16':
                case 'Edm.Byte':
                case 'Edm.Int32':
                case 'Edm.Int64':
                    edmProperty.defaultValue = parseInt(entityProperty._attributes.DefaultValue, 10);
                    break;
                case 'Edm.Decimal':
                case 'Edm.Double':
                    edmProperty.defaultValue = parseFloat(entityProperty._attributes.DefaultValue);
                    break;
                case 'Edm.Boolean':
                    edmProperty.defaultValue = entityProperty._attributes.DefaultValue === 'true';
                    break;
                default:
                    edmProperty.defaultValue = entityProperty._attributes.DefaultValue;
                    break;
            }
        }
        outObject.entityProperties.push(edmProperty);
        if (entityKeys.indexOf(edmProperty.name) !== -1) {
            outObject.entityKeys.push(edmProperty);
        }
        const v2Annotations = (0, v2annotationsSupport_1.convertV2Annotations)(entityProperty._attributes, 'Property', entityProperty._attributes.Name);
        if (v2Annotations.length > 0) {
            annotationLists.push(createAnnotationList(edmProperty.fullyQualifiedName, v2Annotations));
        }
        return outObject;
    }, { entityProperties: [], entityKeys: [] });
}
/**
 * Parse the referential constraint from the EDMX into an object structure.
 *
 * @param referentialConstraints the EDMX referential constraints
 * @param sourceTypeName the name of the source type
 * @param targetTypeName the name of the target type
 * @returns the object representation of the referential constraint.
 */
function parseReferentialConstraint(referentialConstraints, sourceTypeName, targetTypeName) {
    return referentialConstraints.reduce((outArray, refCon) => {
        outArray.push({
            sourceTypeName: sourceTypeName,
            sourceProperty: refCon._attributes.Property,
            targetTypeName: targetTypeName,
            targetProperty: refCon._attributes.ReferencedProperty
        });
        return outArray;
    }, []);
}
/**
 * Parse the v2 referential constraint from the EDMX into an object structure.
 *
 * @param referentialConstraints the v2 referential constraint data
 * @param associationEnds the associations of the service to find the involved EntitySets.
 * @returns the object representation of the referential constraint.
 */
function parseV2ReferentialConstraint(referentialConstraints, associationEnds) {
    return referentialConstraints.reduce((outArray, refCon) => {
        let sourceEnd = associationEnds.find((assEnd) => assEnd.role === refCon.Principal._attributes.Role);
        let targetEnd = associationEnds.find((assEnd) => assEnd.role === refCon.Dependent._attributes.Role);
        if (sourceEnd !== undefined && targetEnd !== undefined) {
            let sourceProperties = (0, utils_1.ensureArray)(refCon.Principal.PropertyRef);
            let targetProperties = (0, utils_1.ensureArray)(refCon.Dependent.PropertyRef);
            if (sourceEnd.multiplicity !== '1') {
                targetEnd = sourceEnd;
                sourceEnd = associationEnds.find((assEnd) => assEnd.role === refCon.Dependent._attributes.Role); // We're reversing them so it will exist for sure
                targetProperties = sourceProperties;
                sourceProperties = (0, utils_1.ensureArray)(refCon.Dependent.PropertyRef);
            }
            for (const sourceProperty of sourceProperties) {
                const propertyIndex = sourceProperties.indexOf(sourceProperty);
                outArray.push({
                    sourceTypeName: sourceEnd.type,
                    sourceProperty: sourceProperty._attributes.Name,
                    targetTypeName: targetEnd.type,
                    targetProperty: targetProperties[propertyIndex]._attributes.Name
                });
            }
        }
        return outArray;
    }, []);
}
/**
 * Parse the EDMX representation of the navigation property in an object structure.
 *
 * @param navigationProperties the navigation property definition
 * @param currentEntityType the current entity type
 * @param entityTypeFQN the name of the current entity type
 * @param annotationLists the list of annotations
 * @returns all the navigation properties from the service
 */
function parseNavigationProperties(navigationProperties, currentEntityType, entityTypeFQN, annotationLists) {
    return navigationProperties.reduce((outArray, navigationProperty) => {
        // V4
        const attributes = navigationProperty._attributes;
        if (isV4NavProperty(attributes)) {
            const matches = attributes.Type.match(collectionRegexp);
            const isCollection = matches !== null;
            const typeName = unalias(matches ? matches[1] : attributes.Type);
            outArray.push({
                _type: 'NavigationProperty',
                name: attributes.Name,
                fullyQualifiedName: `${entityTypeFQN}/${attributes.Name}`,
                partner: attributes.Partner,
                containsTarget: attributes.ContainsTarget === 'true',
                isCollection,
                targetTypeName: typeName,
                referentialConstraint: parseReferentialConstraint((0, utils_1.ensureArray)(navigationProperty.ReferentialConstraint), currentEntityType._attributes.Name, typeName)
            });
        }
        else {
            // V2
            const { Relationship, ToRole, FromRole } = attributes;
            outArray.push({
                _type: 'NavigationProperty',
                name: attributes.Name,
                fullyQualifiedName: `${entityTypeFQN}/${attributes.Name}`,
                relationship: Relationship,
                toRole: ToRole,
                fromRole: FromRole
            });
            const v2Annotations = (0, v2annotationsSupport_1.convertV2Annotations)(attributes, 'NavigationProperty', attributes.Name);
            if (v2Annotations.length > 0) {
                annotationLists.push(createAnnotationList(`${entityTypeFQN}/${attributes.Name}`, v2Annotations));
            }
        }
        return outArray;
    }, []);
}
function parseAssociationSets(associations, namespace, entityContainer) {
    return associations.map((association) => {
        const associationFQN = `${namespace}.${association._attributes.Name}`;
        const associationEnd = (0, utils_1.ensureArray)(association.End).map((endValue) => {
            return {
                entitySet: `${namespace}.${entityContainer._attributes.Name}/${endValue._attributes.EntitySet}`,
                role: endValue._attributes.Role
            };
        });
        return {
            fullyQualifiedName: associationFQN,
            name: association._attributes.Name,
            association: association._attributes.Association,
            associationEnd: associationEnd
        };
    });
}
function parseAssociations(associations, namespace) {
    return associations.map((association) => {
        const associationFQN = `${namespace}.${association._attributes.Name}`;
        const associationEnd = (0, utils_1.ensureArray)(association.End).map((endValue) => {
            return {
                type: endValue._attributes.Type,
                role: endValue._attributes.Role,
                multiplicity: endValue._attributes.Multiplicity
            };
        });
        return {
            fullyQualifiedName: associationFQN,
            name: association._attributes.Name,
            associationEnd: associationEnd,
            referentialConstraints: parseV2ReferentialConstraint((0, utils_1.ensureArray)(association.ReferentialConstraint), associationEnd)
        };
    });
}
function parseEntityTypes(entityTypes, annotationLists, namespace) {
    return entityTypes.reduce((outArray, entityType) => {
        const entityKeyNames = entityType.Key ? getEntityTypeKeys((0, utils_1.ensureArray)(entityType.Key.PropertyRef)) : [];
        const entityTypeFQN = `${namespace}.${entityType._attributes.Name}`;
        const { entityProperties, entityKeys } = parseProperties((0, utils_1.ensureArray)(entityType.Property), entityKeyNames, entityTypeFQN, annotationLists);
        const navigationProperties = parseNavigationProperties((0, utils_1.ensureArray)(entityType.NavigationProperty), entityType, entityTypeFQN, annotationLists);
        const outEntityType = {
            _type: 'EntityType',
            name: entityType._attributes.Name,
            fullyQualifiedName: entityTypeFQN,
            keys: entityKeys,
            entityProperties,
            actions: {},
            navigationProperties: navigationProperties
        };
        const v2Annotations = (0, v2annotationsSupport_1.convertV2Annotations)(entityType._attributes, 'EntityType', entityType._attributes.Name);
        if (v2Annotations.length > 0) {
            annotationLists.push(createAnnotationList(outEntityType.fullyQualifiedName, v2Annotations));
        }
        outArray.push(outEntityType);
        return outArray;
    }, []);
}
function parseComplexTypes(complexTypes, annotationLists, namespace) {
    return complexTypes.reduce((outArray, complexType) => {
        const complexTypeFQN = `${namespace}.${complexType._attributes.Name}`;
        const { entityProperties } = parseProperties((0, utils_1.ensureArray)(complexType.Property), [], complexTypeFQN, annotationLists);
        const navigationProperties = parseNavigationProperties((0, utils_1.ensureArray)(complexType.NavigationProperty), complexType, complexTypeFQN, annotationLists);
        outArray.push({
            _type: 'ComplexType',
            name: complexType._attributes.Name,
            fullyQualifiedName: complexTypeFQN,
            properties: entityProperties,
            navigationProperties
        });
        return outArray;
    }, []);
}
function parseTypeDefinitions(typeDefinitions, namespace) {
    return typeDefinitions.reduce((outArray, typeDefinition) => {
        const typeDefinitionFQN = `${namespace}.${typeDefinition._attributes.Name}`;
        outArray.push({
            _type: 'TypeDefinition',
            name: typeDefinition._attributes.Name,
            fullyQualifiedName: typeDefinitionFQN,
            underlyingType: typeDefinition._attributes.UnderlyingType
        });
        return outArray;
    }, []);
}
function parseEntitySets(entitySets, namespace, entityContainerName, annotationLists) {
    const outEntitySets = entitySets.map((entitySet) => {
        const navigationPropertyBinding = Object.fromEntries((0, utils_1.ensureArray)(entitySet.NavigationPropertyBinding).map((navPropertyBinding) => {
            return [
                navPropertyBinding._attributes.Path,
                `${namespace}.${entityContainerName}/${navPropertyBinding._attributes.Target}`
            ];
        }));
        const outEntitySet = {
            _type: 'EntitySet',
            name: entitySet._attributes.Name,
            entityTypeName: unalias(entitySet._attributes.EntityType),
            navigationPropertyBinding,
            fullyQualifiedName: `${namespace}.${entityContainerName}/${entitySet._attributes.Name}`
        };
        const v2Annotations = (0, v2annotationsSupport_1.convertV2Annotations)(entitySet._attributes, 'EntitySet', entitySet._attributes.Name);
        if (v2Annotations.length > 0) {
            annotationLists.push(createAnnotationList(outEntitySet.fullyQualifiedName, v2Annotations));
        }
        return outEntitySet;
    });
    return outEntitySets;
}
function parseSingletons(singletons, namespace, entityContainerName, annotationLists) {
    const outSingletons = singletons.map((singleton) => {
        const navigationPropertyBinding = Object.fromEntries((0, utils_1.ensureArray)(singleton.NavigationPropertyBinding).map((navPropertyBinding) => {
            return [
                navPropertyBinding._attributes.Path,
                `${namespace}.${entityContainerName}/${navPropertyBinding._attributes.Target}`
            ];
        }));
        const outSingleton = {
            _type: 'Singleton',
            name: singleton._attributes.Name,
            entityTypeName: unalias(singleton._attributes.Type),
            nullable: singleton._attributes.Nullable !== 'false',
            navigationPropertyBinding,
            fullyQualifiedName: `${namespace}.${entityContainerName}/${singleton._attributes.Name}`
        };
        const v2Annotations = (0, v2annotationsSupport_1.convertV2Annotations)(singleton._attributes, 'Singleton', singleton._attributes.Name);
        if (v2Annotations.length > 0) {
            annotationLists.push(createAnnotationList(outSingleton.fullyQualifiedName, v2Annotations));
        }
        return outSingleton;
    });
    return outSingletons;
}
function parseActions(actions, namespace, isFunction) {
    return actions.map((action) => {
        const parameters = (0, utils_1.ensureArray)(action.Parameter);
        const isBound = action._attributes.IsBound === 'true';
        let overload;
        if (isFunction) {
            // function
            // https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_FunctionOverloads
            // Unbound: "The combination of function name and ordered set of parameter types MUST be unique within a schema."
            // Bound:   "The combination of function name, binding parameter type, and ordered set of parameter types MUST be unique within a schema."
            //  ==> consider all parameters for the FQN
            overload = parameters.map((parameter) => unaliasType(parameter._attributes.Type).type).join(',');
        }
        else {
            // action
            overload = isBound ? unaliasType(parameters[0]._attributes.Type).type : ''; // '' = the unbound overload
        }
        const fullyQualifiedName = `${namespace}.${action._attributes.Name}(${overload})`;
        return {
            _type: 'Action',
            name: action._attributes.Name,
            isBound: isBound,
            sourceType: isBound ? unaliasType(parameters[0]._attributes.Type).type : '',
            fullyQualifiedName: fullyQualifiedName,
            isFunction: isFunction,
            parameters: parameters.map((param) => {
                const { isCollection, type } = unaliasType(param._attributes.Type);
                const edmActionParameter = {
                    _type: 'ActionParameter',
                    fullyQualifiedName: `${fullyQualifiedName}/${param._attributes.Name}`,
                    name: `${param._attributes.Name}`,
                    type,
                    isCollection
                };
                if (param._attributes.MaxLength) {
                    edmActionParameter.maxLength = parseInt(param._attributes.MaxLength, 10);
                }
                if (param._attributes.Precision) {
                    edmActionParameter.precision = parseInt(param._attributes.Precision, 10);
                }
                if (param._attributes.Scale) {
                    edmActionParameter.scale = parseInt(param._attributes.Scale, 10);
                }
                edmActionParameter.nullable = param._attributes.Nullable !== 'false';
                return edmActionParameter;
            }),
            returnType: action.ReturnType ? unaliasType(action.ReturnType._attributes.Type).type : '',
            returnCollection: action.ReturnType
                ? action.ReturnType._attributes.Type.match(collectionRegexp) !== null
                : false
        };
    });
}
function parseV2FunctionImport(actions, entitySets, namespace) {
    return actions.map((action) => {
        const targetEntitySet = entitySets.find((et) => et.name === action._attributes.EntitySet);
        const actionFQN = `${namespace}/${action._attributes.Name}`;
        return {
            _type: 'Action',
            name: action._attributes.Name,
            isBound: false,
            sourceType: targetEntitySet ? targetEntitySet.entityTypeName : '',
            fullyQualifiedName: actionFQN,
            isFunction: false,
            parameters: (0, utils_1.ensureArray)(action.Parameter).map((param) => {
                return {
                    _type: 'ActionParameter',
                    name: param._attributes.Name,
                    fullyQualifiedName: `${actionFQN}/${param._attributes.Name}`,
                    type: param._attributes.Type,
                    isCollection: param._attributes.Type.match(/^Collection\(.+\)$/) !== null
                };
            }),
            returnType: action._attributes.ReturnType ? action._attributes.ReturnType : '',
            returnCollection: action._attributes.ReturnType
                ? action._attributes.ReturnType.match(collectionRegexp) !== null
                : false
        };
    });
}
function parseActionImports(imports, namespace) {
    return imports.map((actionOrFunctionImport) => {
        var _a;
        const action = (_a = actionOrFunctionImport._attributes.Function) !== null && _a !== void 0 ? _a : actionOrFunctionImport._attributes.Action;
        return {
            _type: 'ActionImport',
            name: unalias(actionOrFunctionImport._attributes.Name),
            fullyQualifiedName: `${namespace}/${actionOrFunctionImport._attributes.Name}`,
            actionName: unalias(action)
        };
    });
}
function parsePropertyValues(propertyValues, currentTarget, annotationsLists) {
    return propertyValues.map((propertyValue) => {
        // I don't care about the first part but need the rest and the spread operator
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { Annotation, _attributes, ...properties } = propertyValue;
        const outPropertyValue = {};
        if (_attributes) {
            const attributeKey = Object.keys(_attributes).find((keyName) => keyName !== 'Property');
            outPropertyValue.name = _attributes.Property;
            const currentPropertyTarget = `${currentTarget}/${outPropertyValue.name}`;
            if (properties && Object.keys(properties).length > 0) {
                outPropertyValue.value = parseExpression(properties, currentPropertyTarget, annotationsLists, false);
            }
            else if (attributeKey) {
                outPropertyValue.value = parseInlineExpression({ [attributeKey]: _attributes[attributeKey] }, currentPropertyTarget, annotationsLists);
            }
            if (propertyValue.Annotation) {
                const propertyAnnotations = parseAnnotations((0, utils_1.ensureArray)(propertyValue.Annotation), currentPropertyTarget, annotationsLists);
                if (propertyAnnotations && propertyAnnotations.length > 0) {
                    annotationsLists.push(createAnnotationList(currentPropertyTarget, propertyAnnotations));
                }
            }
        }
        return outPropertyValue;
    });
}
function parseRecord(record, currentTarget, annotationsLists) {
    const recordAnnotations = parseAnnotations((0, utils_1.ensureArray)(record.Annotation), currentTarget, annotationsLists);
    const outRecord = {
        type: record._attributes ? unalias(record._attributes.Type) : undefined,
        propertyValues: parsePropertyValues((0, utils_1.ensureArray)(record.PropertyValue), currentTarget, annotationsLists)
    };
    if (recordAnnotations && recordAnnotations.length > 0) {
        outRecord.annotations = recordAnnotations;
    }
    return outRecord;
}
/**
 * Type Guard for the type of the current collection.
 *
 * @param annotation
 * @param propertyNameToCheck
 * @returns true if the collection if of the right type
 */
function isExpressionOfType(annotation, propertyNameToCheck) {
    return annotation[propertyNameToCheck] != null;
}
function parseModelPath(propertyPath, modelPathType) {
    switch (modelPathType) {
        case 'NavigationPropertyPath':
            return { type: 'NavigationPropertyPath', NavigationPropertyPath: propertyPath._text };
        case 'PropertyPath':
            return { type: 'PropertyPath', PropertyPath: propertyPath._text };
        case 'AnnotationPath':
            return { type: 'AnnotationPath', AnnotationPath: propertyPath._text };
        case 'Path':
            return { type: 'Path', Path: propertyPath._text };
    }
}
function parseCollection(collection, currentTarget, annotationsLists) {
    if (isExpressionOfType(collection, 'Record')) {
        const recordArray = (0, utils_1.ensureArray)(collection.Record).map((record, recordIndex) => parseRecord(record, currentTarget + '/' + recordIndex, annotationsLists));
        recordArray.type = 'Record';
        return recordArray;
    }
    else if (isExpressionOfType(collection, 'PropertyPath')) {
        const propertyPathArray = (0, utils_1.ensureArray)(collection.PropertyPath).map((propertyPath) => parseModelPath(propertyPath, 'PropertyPath'));
        propertyPathArray.type = 'PropertyPath';
        return propertyPathArray;
    }
    else if (isExpressionOfType(collection, 'NavigationPropertyPath')) {
        const navPropertyPathArray = (0, utils_1.ensureArray)(collection.NavigationPropertyPath).map((navPropertyPath) => parseModelPath(navPropertyPath, 'NavigationPropertyPath'));
        navPropertyPathArray.type = 'NavigationPropertyPath';
        return navPropertyPathArray;
    }
    else if (isExpressionOfType(collection, 'String')) {
        const stringArray = (0, utils_1.ensureArray)(collection.String).map((stringValue) => ({
            type: 'String',
            String: stringValue._text
        }));
        stringArray.type = 'String';
        return stringArray;
    }
    else if (isExpressionOfType(collection, 'AnnotationPath')) {
        const annotationPathArray = (0, utils_1.ensureArray)(collection.AnnotationPath).map((annotationPath) => parseModelPath(annotationPath, 'AnnotationPath'));
        annotationPathArray.type = 'AnnotationPath';
        return annotationPathArray;
    }
    else if (isExpressionOfType(collection, 'Path')) {
        const pathArray = (0, utils_1.ensureArray)(collection.Path).map((pathDefinition) => parseModelPath(pathDefinition, 'Path'));
        pathArray.type = 'Path';
        return pathArray;
    }
    else if (isExpressionOfType(collection, 'If')) {
        const stringArray = (0, utils_1.ensureArray)(collection.If).map((stringValue) => stringValue._text);
        stringArray.type = 'String';
        return stringArray;
    }
    else if (Object.keys(collection).length === 0) {
        return [];
    }
    else {
        console.error(`Cannot parse ${JSON.stringify(collection)}, collection type is not supported`);
    }
    return [];
}
function parseChildren(expressionWithChild) {
    const keys = Object.keys(expressionWithChild).filter((keyValue) => keyValue !== '_attributes' && keyValue !== 'Annotation');
    let outObj = [];
    keys.forEach((key) => {
        if (Array.isArray(expressionWithChild[key])) {
            outObj = outObj.concat(expressionWithChild[key].map((child) => {
                return parseExpression({ [key]: child }, '', [], true);
            }));
        }
        else {
            outObj.push(parseExpression({ [key]: expressionWithChild[key] }, '', [], true));
        }
    });
    return outObj;
}
function parseInlineExpression(expression, currentTarget, annotationsLists) {
    const expressionKeys = Object.keys(expression);
    if (expressionKeys.length > 1) {
        throw new Error(`Too many expressions defined on a single object ${JSON.stringify(expression)}`);
    }
    const expressionKey = expressionKeys[0];
    switch (expressionKey) {
        case 'String':
            return {
                type: 'String',
                String: expression[expressionKey]
            };
        case 'Bool':
            return {
                type: 'Bool',
                Bool: expression.Bool === 'true'
            };
        case 'Decimal':
            return {
                type: 'Decimal',
                Decimal: parseFloat(expression.Decimal)
            };
        case 'Double':
            return {
                type: 'Double',
                Double: parseFloat(expression.Double)
            };
        case 'Date':
            return {
                type: 'Date',
                Date: expression.Date
            };
        case 'Int':
            return {
                type: 'Int',
                Int: parseInt(expression.Int, 10)
            };
        case 'Float':
            return {
                type: 'Float',
                Float: parseFloat(expression.Float)
            };
        case 'Path':
            return {
                type: 'Path',
                Path: expression.Path
            };
        case 'PropertyPath':
            return {
                type: 'PropertyPath',
                PropertyPath: expression.PropertyPath
            };
        case 'AnnotationPath':
            return {
                type: 'AnnotationPath',
                AnnotationPath: expression.AnnotationPath
            };
        case 'NavigationPropertyPath':
            return {
                type: 'NavigationPropertyPath',
                NavigationPropertyPath: expression.NavigationPropertyPath
            };
        case 'EnumMember':
            return {
                type: 'EnumMember',
                EnumMember: expression[expressionKey]
            };
        case 'Collection':
            return {
                type: 'Collection',
                Collection: parseCollection(expression.Collection, currentTarget, annotationsLists)
            };
        case 'Record':
            return {
                type: 'Record',
                Record: parseRecord(expression.Record, currentTarget, annotationsLists)
            };
        case 'Apply':
            return {
                type: 'Apply',
                $Apply: parseChildren(expression.Apply),
                $Function: parseChildren(expression.Function)
            };
        case 'And':
            return {
                type: 'And',
                $And: parseChildren(expression.And)
            };
        case 'Or':
            return {
                type: 'Or',
                $Or: parseChildren(expression.Or)
            };
        case 'Eq':
            return {
                type: 'Eq',
                $Eq: parseChildren(expression.Eq)
            };
        case 'Gt':
            return {
                type: 'Gt',
                $Gt: parseChildren(expression.Gt)
            };
        case 'Ge':
            return {
                type: 'Ge',
                $Ge: parseChildren(expression.Ge)
            };
        case 'Lt':
            return {
                type: 'Lt',
                $Lt: parseChildren(expression.Lt)
            };
        case 'Le':
            return {
                type: 'Le',
                $Le: parseChildren(expression.Le)
            };
        case 'If':
            return {
                type: 'If',
                $If: parseChildren(expression.If)
            };
        case 'Null':
            return {
                type: 'Null'
            };
        default:
            console.error('Unsupported inline expression type ' + expressionKey);
            return {
                type: 'Unknown'
            };
    }
}
function parseExpression(expression, currentTarget, annotationsLists, simplifyPrimitive) {
    const expressionKeys = Object.keys(expression);
    if (expressionKeys.length > 1) {
        throw new Error(`Too many expressions defined on a single object ${JSON.stringify(expression)}`);
    }
    const expressionKey = expressionKeys[0];
    switch (expressionKey) {
        case 'String':
            if (simplifyPrimitive) {
                return expression[expressionKey]._text;
            }
            return {
                type: 'String',
                String: expression[expressionKey]._text
            };
        case 'LabeledElement':
            return {
                type: 'LabeledElement',
                $Name: expression.LabeledElement._attributes.Name,
                $LabeledElement: parseChildren(expression.LabeledElement)[0]
            };
        case 'Bool':
            if (simplifyPrimitive) {
                return expression.Bool._text === 'true';
            }
            return {
                type: 'Bool',
                Bool: expression.Bool._text === 'true'
            };
        case 'Int':
            if (simplifyPrimitive) {
                return parseInt(expression.Int._text, 10);
            }
            return {
                type: 'Int',
                Int: parseInt(expression.Int._text, 10)
            };
        case 'Decimal':
            if (simplifyPrimitive) {
                return parseFloat(expression.Decimal._text);
            }
            return {
                type: 'Decimal',
                Decimal: parseFloat(expression.Decimal._text)
            };
        case 'Double':
            if (simplifyPrimitive) {
                return parseFloat(expression.Double._text);
            }
            return {
                type: 'Double',
                Decimal: parseFloat(expression.Double._text)
            };
        case 'Path':
            return {
                type: 'Path',
                Path: expression.Path._text
            };
        case 'PropertyPath':
            return {
                type: 'PropertyPath',
                PropertyPath: expression.PropertyPath._text
            };
        case 'NavigationPropertyPath':
            return {
                type: 'NavigationPropertyPath',
                NavigationPropertyPath: expression.NavigationPropertyPath._text
            };
        case 'AnnotationPath':
            return {
                type: 'AnnotationPath',
                AnnotationPath: expression.AnnotationPath._text
            };
        case 'EnumMember':
            return {
                type: 'EnumMember',
                EnumMember: expression[expressionKey]._text
            };
        case 'Collection':
            return {
                type: 'Collection',
                Collection: parseCollection(expression.Collection, currentTarget, annotationsLists)
            };
        case 'Record':
            return {
                type: 'Record',
                Record: parseRecord(expression.Record, currentTarget, annotationsLists)
            };
        case 'Apply':
            return {
                type: 'Apply',
                $Apply: parseChildren(expression.Apply),
                $Function: expression.Apply._attributes.Function
            };
        case 'Null':
            if (simplifyPrimitive) {
                return null;
            }
            return {
                type: 'Null'
            };
        case 'And':
            return {
                type: 'And',
                $And: parseChildren(expression.And)
            };
        case 'Ne':
            return {
                type: 'Ne',
                $Ne: parseChildren(expression.Ne)
            };
        case 'Not':
            return {
                type: 'Not',
                $Not: parseChildren(expression.Not)[0]
            };
        case 'Or':
            return {
                type: 'Or',
                $Or: parseChildren(expression.Or)
            };
        case 'Eq':
            return {
                type: 'Eq',
                $Eq: parseChildren(expression.Eq)
            };
        case 'If':
            return {
                type: 'If',
                $If: parseChildren(expression.If)
            };
        case 'Gt':
            return {
                type: 'Gt',
                $Gt: parseChildren(expression.Gt)
            };
        case 'Ge':
            return {
                type: 'Ge',
                $Ge: parseChildren(expression.Ge)
            };
        case 'Lt':
            return {
                type: 'Lt',
                $Lt: parseChildren(expression.Lt)
            };
        case 'Le':
            return {
                type: 'Le',
                $Le: parseChildren(expression.Le)
            };
        default:
            console.error('Unsupported expression type ' + expressionKey);
            return {
                type: 'Unknown'
            };
    }
}
function parseAnnotation(annotation, currentTarget, annotationsLists) {
    const { Term, Qualifier, ...others } = annotation._attributes;
    const outAnnotation = {
        term: unalias(Term),
        qualifier: Qualifier
    };
    let currentAnnotationTarget = `${currentTarget}@${unalias(Term)}`;
    if (Qualifier !== '' && Qualifier !== undefined) {
        currentAnnotationTarget += `#${Qualifier}`;
    }
    if (others && Object.keys(others).length > 0) {
        outAnnotation.value = parseInlineExpression(others, currentAnnotationTarget, annotationsLists);
    }
    if (annotation.Annotation) {
        const annotationAnnotations = parseAnnotations((0, utils_1.ensureArray)(annotation.Annotation), currentAnnotationTarget, annotationsLists);
        if (annotationAnnotations && annotationAnnotations.length > 0) {
            outAnnotation.annotations = annotationAnnotations;
        }
    }
    const keys = Object.keys(annotation).filter((keyValue) => keyValue !== '_attributes' && keyValue !== 'Annotation');
    if (isExpressionOfType(annotation, 'Record')) {
        outAnnotation.record = parseRecord(annotation.Record, currentAnnotationTarget, annotationsLists);
    }
    else if (isExpressionOfType(annotation, 'Collection')) {
        outAnnotation.collection = parseCollection(annotation.Collection, currentAnnotationTarget, annotationsLists);
    }
    else if (keys.length === 1) {
        outAnnotation.value = parseExpression({ [keys[0]]: annotation[keys[0]] }, currentAnnotationTarget, annotationsLists, false);
    }
    else if (keys.length > 1) {
        console.error(`Cannot parse ${JSON.stringify(annotation)}, expression type is not supported`);
    }
    return outAnnotation;
}
function parseAnnotations(annotations, currentTarget, annotationsLists) {
    return annotations.map((annotation) => parseAnnotation(annotation, currentTarget, annotationsLists));
}
function createAnnotationList(target, annotations) {
    return {
        target: target,
        annotations: annotations
    };
}
/**
 * @param annotationLists
 * @param annotationsLists
 */
function parseAnnotationLists(annotationLists, annotationsLists) {
    annotationLists
        .filter((annotationList) => annotationList._attributes !== undefined)
        .forEach((annotationList) => {
        annotationsLists.push(createAnnotationList(unalias(annotationList._attributes.Target), parseAnnotations((0, utils_1.ensureArray)(annotationList.Annotation), annotationList._attributes.Target, annotationsLists)));
    });
}
function parseSchema(edmSchema, edmVersion, identification) {
    const namespace = edmSchema._attributes.Namespace;
    const annotations = [];
    const entityTypes = parseEntityTypes((0, utils_1.ensureArray)(edmSchema.EntityType), annotations, namespace);
    const complexTypes = parseComplexTypes((0, utils_1.ensureArray)(edmSchema.ComplexType), annotations, namespace);
    const typeDefinitions = parseTypeDefinitions((0, utils_1.ensureArray)(edmSchema.TypeDefinition), namespace);
    let entitySets = [];
    let singletons = [];
    let associationSets = [];
    let entityContainer = {
        _type: 'EntityContainer',
        fullyQualifiedName: ''
    };
    let actions = [];
    let actionImports = [];
    if (edmSchema.EntityContainer) {
        entitySets = parseEntitySets((0, utils_1.ensureArray)(edmSchema.EntityContainer.EntitySet), namespace, edmSchema.EntityContainer._attributes.Name, annotations);
        singletons = parseSingletons((0, utils_1.ensureArray)(edmSchema.EntityContainer.Singleton), namespace, edmSchema.EntityContainer._attributes.Name, annotations);
        associationSets = parseAssociationSets((0, utils_1.ensureArray)(edmSchema.EntityContainer.AssociationSet), namespace, edmSchema.EntityContainer);
        entityContainer = {
            _type: 'EntityContainer',
            name: edmSchema.EntityContainer._attributes.Name,
            fullyQualifiedName: `${namespace}.${edmSchema.EntityContainer._attributes.Name}`
        };
        if (edmVersion === '1.0') {
            actions = actions.concat(parseV2FunctionImport((0, utils_1.ensureArray)(edmSchema.EntityContainer.FunctionImport), entitySets, entityContainer.fullyQualifiedName));
            // major version 4
        }
        else if (edmVersion.startsWith('4.')) {
            // FunctionImports
            actionImports = actionImports.concat(parseActionImports((0, utils_1.ensureArray)(edmSchema.EntityContainer.FunctionImport), entityContainer.fullyQualifiedName));
            // ActionImports
            actionImports = actionImports.concat(parseActionImports((0, utils_1.ensureArray)(edmSchema.EntityContainer.ActionImport), entityContainer.fullyQualifiedName));
        }
        else {
            throw new Error(`Unsupported EDMX version: ${edmVersion}`);
        }
    }
    // major version 4
    if (edmVersion.startsWith('4.')) {
        actions = actions.concat(parseActions((0, utils_1.ensureArray)(edmSchema.Action), namespace, false));
        actions = actions.concat(parseActions((0, utils_1.ensureArray)(edmSchema.Function), namespace, true));
    }
    const associations = parseAssociations((0, utils_1.ensureArray)(edmSchema.Association), namespace);
    parseAnnotationLists((0, utils_1.ensureArray)(edmSchema.Annotations), annotations);
    const annotationMap = {};
    annotationMap[identification] = annotations;
    return {
        associations,
        associationSets,
        annotations: annotationMap,
        entityContainer,
        namespace: namespace,
        entitySets,
        singletons,
        complexTypes,
        typeDefinitions,
        actions,
        actionImports,
        entityTypes
    };
}
function parseReferences(references) {
    return references.reduce((referencesArray, reference) => {
        const includes = (0, utils_1.ensureArray)(reference['edmx:Include']);
        includes.forEach((include) => {
            referencesArray.push({
                uri: reference._attributes.Uri,
                alias: include._attributes.Alias,
                namespace: include._attributes.Namespace
            });
        });
        return referencesArray;
    }, []);
}
let aliases = {};
function unaliasType(type) {
    const collection = type.match(collectionRegexp);
    const _type = collection ? collection[1] : type;
    const unaliasedType = unalias(_type);
    return {
        type: collection ? `Collection(${unaliasedType})` : unaliasedType,
        isCollection: collection !== null
    };
}
function unalias(aliasedValue) {
    var _a;
    if (!aliasedValue) {
        return aliasedValue;
    }
    const separators = ['@', '/', '('];
    const unaliased = [];
    let start = 0;
    for (let end = 0, maybeAlias = true; end < aliasedValue.length; end++) {
        const char = aliasedValue[end];
        if (maybeAlias && char === '.') {
            const alias = aliasedValue.substring(start, end);
            unaliased.push((_a = aliases[alias]) !== null && _a !== void 0 ? _a : alias);
            start = end;
            maybeAlias = false;
        }
        if (separators.includes(char)) {
            unaliased.push(aliasedValue.substring(start, end + 1));
            start = end + 1;
            maybeAlias = true;
        }
    }
    unaliased.push(aliasedValue.substring(start));
    return unaliased.join('');
}
function mergeSchemas(schemas) {
    const associations = schemas.reduce((associationsToReduce, schema) => {
        return associationsToReduce.concat(schema.associations);
    }, []);
    const associationSets = schemas.reduce((associationSetsToReduce, schema) => {
        return associationSetsToReduce.concat(schema.associationSets);
    }, []);
    const entitySets = schemas.reduce((entitySetsToReduce, schema) => {
        return entitySetsToReduce.concat(schema.entitySets);
    }, []);
    const singletons = schemas.reduce((singletonsToReduce, schema) => {
        return singletonsToReduce.concat(schema.singletons);
    }, []);
    const entityTypes = schemas.reduce((entityTypesToReduce, schema) => {
        return entityTypesToReduce.concat(schema.entityTypes);
    }, []);
    const actions = schemas.reduce((actionsToReduce, schema) => {
        return actionsToReduce.concat(schema.actions);
    }, []);
    const actionImports = schemas.reduce((actionImportsToReduce, schema) => {
        return actionImportsToReduce.concat(schema.actionImports);
    }, []);
    const complexTypes = schemas.reduce((complexTypesToReduces, schema) => {
        return complexTypesToReduces.concat(schema.complexTypes);
    }, []);
    const typeDefinitions = schemas.reduce((typeDefinitionsToReduce, schema) => {
        return typeDefinitionsToReduce.concat(schema.typeDefinitions);
    }, []);
    let annotationMap = {};
    schemas.forEach((schema) => {
        annotationMap = Object.assign(annotationMap, schema.annotations);
    });
    let entityContainer;
    let namespace;
    schemas.forEach((schema) => {
        if (schema.entityContainer && Object.keys(schema.entityContainer).length > 0) {
            entityContainer = schema.entityContainer;
            namespace = schema.namespace;
        }
    });
    // V2 case
    entitySets.forEach((entitySet) => {
        const entityType = entityTypes.find((rawEntityType) => rawEntityType.fullyQualifiedName === entitySet.entityTypeName);
        entityType === null || entityType === void 0 ? void 0 : entityType.navigationProperties.forEach((navProp) => {
            const v2NavProp = navProp;
            const associationSet = associationSets.find((assoc) => assoc.association === v2NavProp.relationship);
            if (associationSet) {
                const targetEntitySet = associationSet.associationEnd.find((associationEnd) => associationEnd.entitySet !== entitySet.fullyQualifiedName);
                if (targetEntitySet) {
                    entitySet.navigationPropertyBinding[navProp.name] = targetEntitySet.entitySet;
                }
            }
        });
    });
    entityTypes.forEach((entityType) => {
        entityType.navigationProperties.forEach((navProp) => {
            const v2NavProp = navProp;
            const association = associations.find((assoc) => assoc.fullyQualifiedName === v2NavProp.relationship);
            if (association && association.referentialConstraints && association.referentialConstraints.length > 0) {
                if (association.referentialConstraints[0].sourceTypeName === entityType.fullyQualifiedName) {
                    v2NavProp.referentialConstraint = association.referentialConstraints;
                }
                else {
                    v2NavProp.referentialConstraint = association.referentialConstraints.map((refConstraint) => {
                        return {
                            sourceTypeName: refConstraint.targetTypeName,
                            sourceProperty: refConstraint.targetProperty,
                            targetTypeName: refConstraint.sourceTypeName,
                            targetProperty: refConstraint.sourceProperty
                        };
                    });
                }
            }
        });
    });
    return {
        associations,
        associationSets,
        annotations: annotationMap,
        entityContainer,
        namespace: namespace,
        entitySets,
        singletons,
        complexTypes,
        typeDefinitions,
        actions,
        actionImports,
        entityTypes
    };
}
function createAliasMap(references, schemas) {
    aliases = references.reduce((map, reference) => {
        map[reference.alias] = reference.namespace;
        return map;
    }, {});
    schemas
        .filter((schema) => schema._attributes.Alias)
        .forEach((schema) => {
        aliases[schema._attributes.Alias] = schema._attributes.Namespace;
    });
}
/**
 * Parse an edmx file and return an object structure representing the service definition.
 *
 * @param xml {string} the original XML string
 * @param fileIdentification {string} a way to identify this file
 * @returns the parsed metadata definition
 */
function parse(xml, fileIdentification = 'serviceFile') {
    const jsonObj = (0, xml_js_1.xml2js)(xml, { compact: true });
    const version = jsonObj['edmx:Edmx']._attributes.Version;
    const schemas = (0, utils_1.ensureArray)(jsonObj['edmx:Edmx']['edmx:DataServices'].Schema);
    const references = parseReferences((0, utils_1.ensureArray)(jsonObj['edmx:Edmx']['edmx:Reference']));
    createAliasMap(references, schemas);
    const parsedSchemas = schemas.map((schema) => {
        return parseSchema(schema, version, fileIdentification);
    });
    const edmxDocument = new utils_1.RawMetadataInstance(fileIdentification, version, mergeSchemas(parsedSchemas), references);
    return edmxDocument;
}
exports.parse = parse;
//# sourceMappingURL=parser.js.map