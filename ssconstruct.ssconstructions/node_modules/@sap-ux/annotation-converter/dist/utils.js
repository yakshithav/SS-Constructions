"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeAnnotations = exports.addGetByValue = exports.createIndexedFind = exports.lazy = exports.Decimal = exports.Double = exports.isComplexTypeDefinition = exports.unalias = exports.alias = exports.substringBeforeLast = exports.substringBeforeFirst = exports.splitAtLast = exports.splitAtFirst = exports.defaultReferences = exports.TermToTypes = exports.EnumIsFlag = void 0;
var EnumIsFlag_1 = require("@sap-ux/vocabularies-types/vocabularies/EnumIsFlag");
Object.defineProperty(exports, "EnumIsFlag", { enumerable: true, get: function () { return EnumIsFlag_1.EnumIsFlag; } });
var TermToTypes_1 = require("@sap-ux/vocabularies-types/vocabularies/TermToTypes");
Object.defineProperty(exports, "TermToTypes", { enumerable: true, get: function () { return TermToTypes_1.TermToTypes; } });
var VocabularyReferences_1 = require("@sap-ux/vocabularies-types/vocabularies/VocabularyReferences");
Object.defineProperty(exports, "defaultReferences", { enumerable: true, get: function () { return VocabularyReferences_1.VocabularyReferences; } });
function splitAt(string, index) {
    return index < 0 ? [string, ''] : [string.substring(0, index), string.substring(index + 1)];
}
function substringAt(string, index) {
    return index < 0 ? string : string.substring(0, index);
}
/**
 * Splits a string at the first occurrence of a separator.
 *
 * @param string    The string to split
 * @param separator Separator, e.g. a single character.
 * @returns An array consisting of two elements: the part before the first occurrence of the separator and the part after it. If the string does not contain the separator, the second element is the empty string.
 */
function splitAtFirst(string, separator) {
    return splitAt(string, string.indexOf(separator));
}
exports.splitAtFirst = splitAtFirst;
/**
 * Splits a string at the last occurrence of a separator.
 *
 * @param string    The string to split
 * @param separator Separator, e.g. a single character.
 * @returns An array consisting of two elements: the part before the last occurrence of the separator and the part after it. If the string does not contain the separator, the second element is the empty string.
 */
function splitAtLast(string, separator) {
    return splitAt(string, string.lastIndexOf(separator));
}
exports.splitAtLast = splitAtLast;
/**
 * Returns the substring before the first occurrence of a separator.
 *
 * @param string    The string
 * @param separator Separator, e.g. a single character.
 * @returns The substring before the first occurrence of the separator, or the input string if it does not contain the separator.
 */
function substringBeforeFirst(string, separator) {
    return substringAt(string, string.indexOf(separator));
}
exports.substringBeforeFirst = substringBeforeFirst;
/**
 * Returns the substring before the last occurrence of a separator.
 *
 * @param string    The string
 * @param separator Separator, e.g. a single character.
 * @returns The substring before the last occurrence of the separator, or the input string if it does not contain the separator.
 */
function substringBeforeLast(string, separator) {
    return substringAt(string, string.lastIndexOf(separator));
}
exports.substringBeforeLast = substringBeforeLast;
/**
 * Transform an unaliased string representation annotation to the aliased version.
 *
 * @param references currentReferences for the project
 * @param unaliasedValue the unaliased value
 * @returns the aliased string representing the same
 */
function alias(references, unaliasedValue) {
    if (!references.reverseReferenceMap) {
        references.reverseReferenceMap = references.reduce((map, ref) => {
            map[ref.namespace] = ref;
            return map;
        }, {});
    }
    if (!unaliasedValue) {
        return unaliasedValue;
    }
    const [namespace, value] = splitAtLast(unaliasedValue, '.');
    const reference = references.reverseReferenceMap[namespace];
    if (reference) {
        return `${reference.alias}.${value}`;
    }
    else if (unaliasedValue.includes('@')) {
        // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
        const [preAlias, postAlias] = splitAtFirst(unaliasedValue, '@');
        return `${preAlias}@${alias(references, postAlias)}`;
    }
    else {
        return unaliasedValue;
    }
}
exports.alias = alias;
/**
 * Transform an aliased string to its unaliased version given a set of references.
 *
 * @param references The references to use for unaliasing.
 * @param aliasedValue The aliased value
 * @param namespace The fallback namespace
 * @returns The equal unaliased string.
 */
function unalias(references, aliasedValue, namespace) {
    var _a;
    const _unalias = (value) => {
        if (!references.referenceMap) {
            references.referenceMap = Object.fromEntries(references.map((ref) => [ref.alias, ref]));
        }
        // Aliases are of type 'SimpleIdentifier' and must not contain dots
        const [maybeAlias, rest] = splitAtFirst(value, '.');
        if (!rest || rest.includes('.')) {
            // either there is no dot in the value or there is more than one --> nothing to do
            return value;
        }
        const isAnnotation = maybeAlias.startsWith('@');
        const valueToUnalias = isAnnotation ? maybeAlias.substring(1) : maybeAlias;
        const knownReference = references.referenceMap[valueToUnalias];
        if (knownReference) {
            return isAnnotation ? `@${knownReference.namespace}.${rest}` : `${knownReference.namespace}.${rest}`;
        }
        // The alias could not be resolved using the references. Assume it is the "global" alias (= namespace)
        return namespace && !isAnnotation ? `${namespace}.${rest}` : value;
    };
    return (_a = aliasedValue === null || aliasedValue === void 0 ? void 0 : aliasedValue.split('/').reduce((segments, segment) => {
        // the segment could be an action, like "doSomething(foo.bar)"
        const [first, rest] = splitAtFirst(segment, '(');
        const subSegment = [_unalias(first)];
        if (rest) {
            const parameter = rest.slice(0, -1); // remove trailing ")"
            subSegment.push(`(${_unalias(parameter)})`);
        }
        segments.push(subSegment.join(''));
        return segments;
    }, [])) === null || _a === void 0 ? void 0 : _a.join('/');
}
exports.unalias = unalias;
/**
 * Differentiate between a ComplexType and a TypeDefinition.
 *
 * @param complexTypeDefinition
 * @returns true if the value is a complex type
 */
function isComplexTypeDefinition(complexTypeDefinition) {
    return (!!complexTypeDefinition && complexTypeDefinition._type === 'ComplexType' && !!complexTypeDefinition.properties);
}
exports.isComplexTypeDefinition = isComplexTypeDefinition;
function Double(value) {
    return {
        isDouble() {
            return true;
        },
        valueOf() {
            return value;
        },
        toString() {
            return value.toString();
        }
    };
}
exports.Double = Double;
function Decimal(value) {
    return {
        isDecimal() {
            return true;
        },
        valueOf() {
            return value;
        },
        toString() {
            return value.toString();
        }
    };
}
exports.Decimal = Decimal;
/**
 * Defines a lazy property.
 *
 * The property is initialized by calling the init function on the first read access, or by directly assigning a value.
 *
 * @param object    The host object
 * @param property  The lazy property to add
 * @param init      The function that initializes the property's value
 */
function lazy(object, property, init) {
    const initial = Symbol('initial');
    let _value = initial;
    Object.defineProperty(object, property, {
        enumerable: true,
        get() {
            if (_value === initial) {
                _value = init();
            }
            return _value;
        },
        set(value) {
            _value = value;
        }
    });
}
exports.lazy = lazy;
/**
 * Creates a function that allows to find an array element by property value.
 *
 * @param array     The array
 * @param property  Elements in the array are searched by this property
 * @returns A function that can be used to find an element of the array by property value.
 */
function createIndexedFind(array, property) {
    const index = new Map();
    return function find(value) {
        const element = index.get(value);
        if ((element === null || element === void 0 ? void 0 : element[property]) === value) {
            return element;
        }
        return array.find((element) => {
            if (!(element === null || element === void 0 ? void 0 : element.hasOwnProperty(property))) {
                return false;
            }
            const propertyValue = element[property];
            index.set(propertyValue, element);
            return propertyValue === value;
        });
    };
}
exports.createIndexedFind = createIndexedFind;
/**
 * Adds a 'get by value' function to an array.
 *
 * If this function is called with addIndex(myArray, 'name'), a new function 'by_name(value)' will be added that allows to
 * find a member of the array by the value of its 'name' property.
 *
 * @param array      The array
 * @param property   The property that will be used by the 'by_{property}()' function
 * @returns The array with the added function
 */
function addGetByValue(array, property) {
    const indexName = `by_${property}`;
    if (!array.hasOwnProperty(indexName)) {
        Object.defineProperty(array, indexName, { writable: false, value: createIndexedFind(array, property) });
    }
    else {
        throw new Error(`Property '${indexName}' already exists`);
    }
    return array;
}
exports.addGetByValue = addGetByValue;
/**
 * Merge annotations from different sources together by overwriting at the term level.
 *
 * @param references        References, used to resolve aliased annotation targets and aliased annotation terms.
 * @param annotationSources Annotation sources
 * @returns the resulting merged annotations
 */
function mergeAnnotations(references, ...annotationSources) {
    return annotationSources.reduceRight((result, { name, annotationList }) => {
        var _a;
        for (const { target, annotations } of annotationList) {
            const annotationTarget = (_a = unalias(references, target)) !== null && _a !== void 0 ? _a : target;
            if (!result[annotationTarget]) {
                result[annotationTarget] = [];
            }
            const annotationsOnTarget = annotations
                .map((rawAnnotation) => {
                var _a;
                rawAnnotation.term = (_a = unalias(references, rawAnnotation.term)) !== null && _a !== void 0 ? _a : rawAnnotation.term;
                rawAnnotation.fullyQualifiedName = rawAnnotation.qualifier
                    ? `${annotationTarget}@${rawAnnotation.term}#${rawAnnotation.qualifier}`
                    : `${annotationTarget}@${rawAnnotation.term}`;
                rawAnnotation.__source = name;
                return rawAnnotation;
            })
                .filter((annotation) => !result[annotationTarget].some((existingAnnotation) => existingAnnotation.term === annotation.term &&
                existingAnnotation.qualifier === annotation.qualifier));
            result[annotationTarget].push(...annotationsOnTarget);
        }
        return result;
    }, {});
}
exports.mergeAnnotations = mergeAnnotations;
//# sourceMappingURL=utils.js.map