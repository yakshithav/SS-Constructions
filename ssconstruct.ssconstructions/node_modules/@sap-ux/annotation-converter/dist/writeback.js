"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.revertTermToGenericType = void 0;
const utils_1 = require("./utils");
/**
 * Revert an object to its raw type equivalent.
 *
 * @param references the current reference
 * @param value the value to revert
 * @returns the raw value
 */
function revertObjectToRawType(references, value) {
    var _a, _b, _c, _d, _e, _f, _g;
    let result;
    if (Array.isArray(value)) {
        // Special case of flag enum type
        const firstValue = value[0];
        let isEnumFlags = false;
        if (firstValue && typeof firstValue === 'string') {
            const valueMatches = firstValue.valueOf().split('.');
            if (valueMatches.length > 1 && references.find((ref) => ref.alias === valueMatches[0])) {
                isEnumFlags = utils_1.EnumIsFlag[(0, utils_1.substringBeforeFirst)(firstValue, '/')];
            }
        }
        if (isEnumFlags) {
            result = {
                type: 'EnumMember',
                EnumMember: value.map((val) => val.valueOf()).join(' ')
            };
        }
        else {
            result = {
                type: 'Collection',
                Collection: value.map((anno) => revertCollectionItemToRawType(references, anno))
            };
        }
    }
    else if ((_a = value.isDecimal) === null || _a === void 0 ? void 0 : _a.call(value)) {
        result = {
            type: 'Decimal',
            Decimal: value.valueOf()
        };
    }
    else if ((_b = value.isDouble) === null || _b === void 0 ? void 0 : _b.call(value)) {
        result = {
            type: 'Double',
            Double: value.valueOf()
        };
    }
    else if ((_c = value.isString) === null || _c === void 0 ? void 0 : _c.call(value)) {
        const valueMatches = value.valueOf().split('.');
        if (valueMatches.length > 1 && references.find((ref) => ref.alias === valueMatches[0])) {
            result = {
                type: 'EnumMember',
                EnumMember: value.valueOf()
            };
        }
        else {
            result = {
                type: 'String',
                String: value.valueOf()
            };
        }
    }
    else if ((_d = value.isInt) === null || _d === void 0 ? void 0 : _d.call(value)) {
        result = {
            type: 'Int',
            Int: value.valueOf()
        };
    }
    else if ((_e = value.isFloat) === null || _e === void 0 ? void 0 : _e.call(value)) {
        result = {
            type: 'Float',
            Float: value.valueOf()
        };
    }
    else if ((_f = value.isDate) === null || _f === void 0 ? void 0 : _f.call(value)) {
        result = {
            type: 'Date',
            Date: value.valueOf()
        };
    }
    else if ((_g = value.isBoolean) === null || _g === void 0 ? void 0 : _g.call(value)) {
        result = {
            type: 'Bool',
            Bool: value.valueOf()
        };
    }
    else if (value.type === 'Path') {
        result = {
            type: 'Path',
            Path: value.path
        };
    }
    else if (value.type === 'AnnotationPath') {
        result = {
            type: 'AnnotationPath',
            AnnotationPath: value.value
        };
    }
    else if (value.type === 'Apply') {
        result = {
            type: 'Apply',
            $Apply: value.$Apply,
            $Function: value.$Function
        };
    }
    else if (value.type === 'Null') {
        result = {
            type: 'Null'
        };
    }
    else if (value.type === 'PropertyPath') {
        result = {
            type: 'PropertyPath',
            PropertyPath: value.value
        };
    }
    else if (value.type === 'NavigationPropertyPath') {
        result = {
            type: 'NavigationPropertyPath',
            NavigationPropertyPath: value.value
        };
    }
    else if (Object.prototype.hasOwnProperty.call(value, '$Type')) {
        result = {
            type: 'Record',
            Record: revertCollectionItemToRawType(references, value)
        };
    }
    return result;
}
/**
 * Revert a value to its raw value depending on its type.
 *
 * @param references the current set of reference
 * @param value the value to revert
 * @returns the raw expression
 */
function revertValueToRawType(references, value) {
    let result;
    if (value.type === 'Constant') {
        value = value.value;
    }
    const valueConstructor = value === null || value === void 0 ? void 0 : value.constructor.name;
    switch (valueConstructor) {
        case 'String':
        case 'string':
            const valueMatches = value.toString().split('.');
            if (valueMatches.length > 1 && references.find((ref) => ref.alias === valueMatches[0])) {
                result = {
                    type: 'EnumMember',
                    EnumMember: value.toString()
                };
            }
            else {
                result = {
                    type: 'String',
                    String: value.toString()
                };
            }
            break;
        case 'Boolean':
        case 'boolean':
            result = {
                type: 'Bool',
                Bool: value.valueOf()
            };
            break;
        case 'Number':
        case 'number':
            if (value.toString() === value.toFixed()) {
                result = {
                    type: 'Int',
                    Int: value.valueOf()
                };
            }
            else {
                result = {
                    type: 'Decimal',
                    Decimal: value.valueOf()
                };
            }
            break;
        case 'object':
        default:
            result = revertObjectToRawType(references, value);
            break;
    }
    return result;
}
const restrictedKeys = ['$Type', 'term', '__source', 'qualifier', 'ActionTarget', 'fullyQualifiedName', 'annotations'];
/**
 * Revert the current embedded annotations to their raw type.
 *
 * @param references the current set of reference
 * @param currentAnnotations the collection item to evaluate
 * @param targetAnnotations the place where we need to add the annotation
 */
function revertAnnotationsToRawType(references, currentAnnotations, targetAnnotations) {
    Object.keys(currentAnnotations)
        .filter((key) => key !== '_annotations')
        .forEach((key) => {
        Object.keys(currentAnnotations[key]).forEach((term) => {
            const parsedAnnotation = revertTermToGenericType(references, currentAnnotations[key][term]);
            if (!parsedAnnotation.term) {
                const unaliasedTerm = (0, utils_1.unalias)(references, `${key}.${term}`);
                if (unaliasedTerm) {
                    const qualifiedSplit = unaliasedTerm.split('#');
                    parsedAnnotation.term = qualifiedSplit[0];
                    if (qualifiedSplit.length > 1) {
                        // Sub Annotation with a qualifier, not sure when that can happen in real scenarios
                        parsedAnnotation.qualifier = qualifiedSplit[1];
                    }
                }
            }
            targetAnnotations.push(parsedAnnotation);
        });
    });
}
/**
 * Revert the current collection item to the corresponding raw annotation.
 *
 * @param references the current set of reference
 * @param collectionItem the collection item to evaluate
 * @returns the raw type equivalent
 */
function revertCollectionItemToRawType(references, collectionItem) {
    if (typeof collectionItem === 'string') {
        return {
            type: 'String',
            String: collectionItem
        };
    }
    else if (typeof collectionItem === 'object') {
        if (collectionItem.hasOwnProperty('$Type')) {
            // Annotation Record
            const outItem = {
                type: collectionItem.$Type,
                propertyValues: []
            };
            // Could validate keys and type based on $Type
            Object.keys(collectionItem).forEach((collectionKey) => {
                if (restrictedKeys.indexOf(collectionKey) === -1) {
                    const value = collectionItem[collectionKey];
                    outItem.propertyValues.push({
                        name: collectionKey,
                        value: revertValueToRawType(references, value)
                    });
                }
                else if (collectionKey === 'annotations' && Object.keys(collectionItem[collectionKey]).length > 0) {
                    outItem.annotations = [];
                    revertAnnotationsToRawType(references, collectionItem[collectionKey], outItem.annotations);
                }
            });
            return outItem;
        }
        else if (collectionItem.type === 'PropertyPath') {
            return {
                type: 'PropertyPath',
                PropertyPath: collectionItem.value
            };
        }
        else if (collectionItem.type === 'AnnotationPath') {
            return {
                type: 'AnnotationPath',
                AnnotationPath: collectionItem.value
            };
        }
        else if (collectionItem.type === 'NavigationPropertyPath') {
            return {
                type: 'NavigationPropertyPath',
                NavigationPropertyPath: collectionItem.value
            };
        }
        else if (collectionItem.type === 'Constant') {
            return collectionItem.value;
        }
    }
    return undefined;
}
/**
 * Revert an annotation term to it's generic or raw equivalent.
 *
 * @param references the reference of the current context
 * @param annotation the annotation term to revert
 * @returns the raw annotation
 */
function revertTermToGenericType(references, annotation) {
    const baseAnnotation = {
        term: annotation.term,
        qualifier: annotation.qualifier
    };
    if (Array.isArray(annotation)) {
        // Collection
        if (annotation.hasOwnProperty('annotations') && Object.keys(annotation.annotations).length > 0) {
            // Annotation on a collection itself, not sure when that happens if at all
            baseAnnotation.annotations = [];
            revertAnnotationsToRawType(references, annotation.annotations, baseAnnotation.annotations);
        }
        return {
            ...baseAnnotation,
            collection: annotation.map((anno) => revertCollectionItemToRawType(references, anno))
        };
    }
    else if (annotation.hasOwnProperty('$Type')) {
        return { ...baseAnnotation, record: revertCollectionItemToRawType(references, annotation) };
    }
    else {
        return { ...baseAnnotation, value: revertValueToRawType(references, annotation) };
    }
}
exports.revertTermToGenericType = revertTermToGenericType;
//# sourceMappingURL=writeback.js.map